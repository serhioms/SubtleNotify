# SubtleNotify

Уведомления не случайны, т.е. предсказуемы, но не очевидным образом. Поэтому проект называется **SubtleNotify** - тонкое уведомление.

## Контракт

### REST API с методами:

- **POST /action** — добавить действие пользователя
  ```json
  {
    "userId": "string",
    "actionType": "string",
    "timestamp": "string"
  }
  ```

- **GET /notifications** — получить все уведомления, сгенерированные системой

> **PS:** Чуть изменил контракт. Единственное число принято в нэйминге где это возможно. Допускаются смысловые исключения, поэтому `action`, а не `actions`.

### Логика

**actionType** - имя триггер-файла с правилами и уведомлениями.

При каждом action-запросе делать запрос к БД с целью сформировать статистику по конкретному `userId` и `actionType` в виде ряда `timestamp`. Далее применяем правила из одноименного триггер-файла. Если какое-либо правило срабатывает, то сохраняем "непредсказуемое" уведомление в БД.

## Архитектура

Вместо того чтобы формировать статистику в процессе синхронно, нужно запускать асинхронные задачи по очереди, где и формировать статистику, и применять триггеры, и сохранять уведомления в БД.

### Плюсы/минусы:

- ✅ Уменьшаем время работы микросервиса в рамках контракта
- ✅ Контролируем нагрузку на сервер ограниченным пулом рабочих потоков
- ✅ Система легко расширяется на новые actionType добавлением новых файл-триггеров
- ⚠️ Файлы не самый хороший способ хранения триггеров в распределённых системах, поэтому заменяем их на таблицы БД
- ➕ Добавляем новый сервис для редактирования триггеров...

### Ключевые классы:

_??????_

## Эвристика непредсказуемости

Обыкновенное условное правило "если-то" с соответствующим уведомлением. Например, если статистика удовлетворяет некоторому условию, то применить уведомление. Если уведомлений несколько, выбрать одно случайным образом.

## Решение

Такое условное правило называют **предикатом**, а уведомление - **телом предиката**, например в Прологе. Тело довольно простое - строка уведомления. Но логика вычисления истинности предиката довольно сложная: собранная статистика по `userId` должна удовлетворять некоторым критериям. Для вычисления такого условия нужен **решатель**!

### Варианты имплементации самописных решателей:

1. **CoreJava решатель** в виде, например, функционального выражения
2. **SQL решатель** в виде хитроумного SQL запроса

**CoreJava решатель** не соответствует духу динамического добавления триггеров в БД, поскольку требует модификации кода при каждом добавлении нового actionType.

**SQL решатель** добавляет динамику, но ограничивает вычислительные способности рамками синтаксиса SQL запросов.

### Комбинированный подход

Видимо придется комбинировать... Усилить SQL функциональным выражением Java по принципу: **всё статичное в Java, а динамичное в SQL**.

Для добавления новых триггеров можно использовать формализованный текст или структуру данных типа JSON. Второе предпочтительнее, поскольку проще и ложится на логику REST приложения (не нужно писать парсер для формального текста).

  ```json
  {
??????
  }
  ```

Исходя из JSON структуры триггера будет записано и функциональное Java выражение, и необходимые SQL запросы к соответствующей схеме собранной статистики. Чем сложнее и витиеватее структура, тем сложнее БД схема статистики и соответственно её расчёт в процессе регистрации action-запросов. В первой версии постараемся ограничиться триггерами простой и средней сложности с потенциальной возможностью будущих усложнений.

## Примеры SubtleNotify

Для задания JSON структуры триггера рассмотрим следующие примеры:

1. **пишет комментарии** - ночью три дня подряд → утром уведомление
2. **покупает кофе** - по пн, ср, пт → во вторник уведомление
3. **открывает приложение** - каждый день в 9м часу → если открыл в 8м, немедленно уведомить
4. **читает статьи** - по воскресениям → в субботу вечером уведомить
5. **заказывает доставку** - через день → на третий цикл уведомить
6. **пьёт чай** - каждый вечер → если пропустил, уведомить следующим днём
7. **делает шаги** - в 10м часу каждый день → утром уведомить
8. **проверяет задачи** - после обеда → утром уведомить
9. **ставит лайки** - по средам → уведомить с утра

## Требования к статистике

### Измерения:

1. **День недели**
2. **Час дня**
3. **Время дня** - утро, день, вечер, ночь, после обеда, до обеда, перед сном

### Структура уведомления:

1. **Время** - за Х минут перед временем дня в конкретную дату
2. **Текст**